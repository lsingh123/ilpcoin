<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ilpcoin.ilp_queue.ilp_queue API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ilpcoin.ilp_queue.ilp_queue</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import List, Set
from flask import Flask, request
import requests
from ilpcoin.common.ilp import *
from ilpcoin.common.constants import *
import ilpcoin.common.constants
from ilpcoin.common.sample_ilps.random_knapsack import random_knapsack
import queue
import logging
import threading
from random import sample

class IlpQueue:
    &#39;&#39;&#39;IlpQueue represents the state for a queue of Ilps. 
    
    The ilp-queue application is backed by this data structure.

    Attributes
    ----------
    q : queue.Queue
        The underlying Python queue that stores the Ilps. 
    top : Optional[Ilp]
        The current Ilp at the head of the queue. This is the Ilp currently being solved 
        by the blockchain.
    count : int
        The number of verifiers who report having solved `top`. 
    ilp_history : dict[int, Ilp]
        A dictionary of every Ilp that has ever been on the queue, indexed by their uid.
    last_used_uid : int
        The most recently assigned uid. ID&#39;s are not reused, and this is incremented after each new id is provisioned. 
    verifiers : List[int]
        The set of verifiers that the queue knows about. Verifiers register with the queue on initialization.
    generate_random_ilps : bool
        Set to true if the queue should generate random Ilps to ensure there is always an Ilp available. In
        general, this is set to true, but we switch it to false for deterministic unit testing.
    &#39;&#39;&#39;

    def __init__(self, initial_verifiers : List[int] = [], generate_random_ilps = True):
        &#39;&#39;&#39;Initializes a new IlpQueue.
        
        In the future, this could be written to a database frequently, and restored from the database 
        on startup.
        &#39;&#39;&#39;
        self.q = queue.Queue() 
        self.top : Optional[Ilp] = None 
        self.count : int = 0   
        self.ilp_history : dict[int, Ilp] = {} 
        self.last_used_uid = 0 
        self.verifiers = initial_verifiers
        self._last_used_verifier = 0 # used the ensure different subsets of verifiers are given when queue is used as a DNS
        self.generate_random_ilps = generate_random_ilps
        if self.generate_random_ilps: 
            self.__add_random_ilp()

    def add(self, ilp : Ilp) -&gt; int:
        &#39;&#39;&#39;Add an Ilp (see `Ilp`for representation) to the back of the queue.&#39;&#39;&#39;
        self.last_used_uid += 1
        ilp.set_id(self.last_used_uid)
        self.q.put(ilp)
        self.ilp_history[ilp.get_id()] = ilp
        if not self.top: 
            self.top = self.q.get()
            logging.debug(f&#34;Top ILP has ID {self.top.get_id()}&#34;)
        return ilp.get_id()
    
    # Return a verifier ip, different from the last time
    def get_verifier_ip(self) -&gt; Optional[int]: 
        &#39;&#39;&#39;Return the id of a ranndom verifier known to be on the network. 
        
        Cycles through verifiers to avoid repetition.
        &#39;&#39;&#39;
        
        if not self.verifiers: 
            return None

        self._last_used_verifier += 1

        return self.verifiers[self._last_used_verifier % len(self.verifiers)]

    def add_verifer(self, ip): 
        &#39;&#39;&#39;Make the queue aware of a new verifier, with address `ip`&#39;&#39;&#39;
        self.verifiers.append(ip)

    def get_top(self) -&gt; Optional[Ilp]:
        &#39;&#39;&#39;Return the Ilp the blockchain is currently working on. None otherwise.&#39;&#39;&#39;
        return self.top

    def lookup_ilp(self, id : int) -&gt; Optional[Ilp]:
        &#39;&#39;&#39;Return the ilp matching `id`.&#39;&#39;&#39;
        try:
            return self.ilp_history[id]
        except:
            return None
    
    # Add a random Ilp to the queue
    def __add_random_ilp(self): 
        self.add(random_knapsack())

    # Increment the queue to the next element; called when enough verifiers have 
    # checked the solution. 
    def __complete_item(self) -&gt; None:
        logging.debug(&#34;Ilp with id &#34; + str(self.top.get_id()) + &#34; is popped from queue.&#34;) 

        if not self.q.empty():
            self.top = self.q.get()
        else:
            if self.generate_random_ilps: 
                self.__add_random_ilp()
                self.top = self.q.get()
            else: 
                self.top = None

        self.count = 0

    def incr_count(self, uid : int) -&gt; bool:
        &#39;&#39;&#39;Called when a verifier tells the queue that it has solved the top ilp. 
        
        Increments count, and cycles to next Ilp if necessary. 
        &#39;&#39;&#39;
        if not self.get_top():
            return False

        if (self.get_top().get_id() != int(uid)):
            logging.debug(f&#34;Verifying ILP w ID {uid} but top of the queue is {self.get_top().get_id()}&#34;)
            return False

        self.count += 1
        if(self.count &gt;= ilpcoin.common.constants.VERIFIERS_NEEDED):
            self.__complete_item()
        logging.debug(f&#34;Registering solution for ilp with id {uid}&#34;)
        return True


# The main ilp_queue, that backs the Flask application below.
ilp_queue = IlpQueue(generate_random_ilps=True)

# The queue application. 
app = Flask(__name__)

@app.route(&#39;/add_ilp&#39;, methods=[&#39;POST&#39;])
def add_ilp():
    &#39;&#39;&#39;Add the serialized Ilp passed through the request form (encoded as a hexidecimal string).
    
    Returns the ID of the new Ilp.
    &#39;&#39;&#39;
    new_ilp_serialized : str = request.form[&#39;ilp&#39;]
    if not new_ilp_serialized:
        return FAILURE

    new_ilp = Ilp.deserialize_s(new_ilp_serialized)
    ilp_queue.add(new_ilp)

    logging.debug(f&#34;Added new ilp with ID {new_ilp.get_id()}&#34;)
    return str(new_ilp.get_id())

@app.route(&#39;/get_top_ilp&#39;, methods=[&#39;GET&#39;])
def get_top_ilp():
    &#39;&#39;&#39;Return a hex string serialized Ilp on the top of the queue, if available.
    
    Returns ILP_NOT_FOUND on failure.&#39;&#39;&#39;
    result = ilp_queue.get_top()
    return result.serialize_s() if result else ILP_NOT_FOUND

@app.route(&#39;/get_ilp_by_id/&lt;uid&gt;&#39;, methods=[&#39;GET&#39;])
def get_ilp_by_id(uid):
    &#39;&#39;&#39;Return a hex string serialization if the Ilp with id `uid`&#39;&#39;&#39;
    logging.debug(&#34;Looking up ilp with id: &#34; + uid)
    result = ilp_queue.lookup_ilp(int(uid))
    return result.serialize_s() if result else ILP_NOT_FOUND

@app.route(&#39;/get_solution_by_id/&lt;uid&gt;&#39;, methods=[&#39;GET&#39;])
def get_solution_by_id(uid, tries : int = 3):
    &#39;&#39;&#39; Try `tries` times to query random verifiers for a solution to Ilp with id `uid`&#39;&#39;&#39;
    for i in range(tries): 
        id = ilp_queue.get_verifier_ip()
        if not id: 
            return NO_VERIFIERS
        r = requests.get(&#34;http://&#34; + (HOST + &#34;:&#34; + str(int(PORT) + int(id))) + &#34;/get_ilp_solution/&#34; + str(uid), timeout=3)
        if r.text: 
            return r.text
    return TIMEOUT

@app.route(&#39;/verify_ilp/&lt;ilp_id&gt;&#39;, methods=[&#39;GET&#39;])
def verify_ilp(ilp_id):
    &#39;&#39;&#39;Announce to the queue that you have verified a solution for ilp_id.&#39;&#39;&#39;
    return SUCCESS if ilp_queue.incr_count(ilp_id) else NOT_TOP_ILP

@app.route(&#39;/register_verifier/&lt;address&gt;&#39;, methods=[&#39;GET&#39;])
def register_verifier(address): 
    &#39;&#39;&#39;Announce to the queue that verifier at `address` is online&#39;&#39;&#39;
    if not address in ilp_queue.verifiers: 
        ilp_queue.add_verifer(address)
    return SUCCESS

@app.route(&#39;/get_neighbors/&lt;n&gt;&#39;, methods=[&#39;GET&#39;])
def get_neighbors(n):
    &#39;&#39;&#39;Returns a pickled list of n verifier IDs that the queue know about. If 
    fewer than n verifiers are known, returns all verifiers.
    &#39;&#39;&#39;
    try: 
        res = sample(ilp_queue.verifiers, n)
    except: 
        res = ilp_queue.verifiers
    logging.debug(f&#34;sending neighbors {res}&#34;)
    return pickle.dumps(res)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ilpcoin.ilp_queue.ilp_queue.add_ilp"><code class="name flex">
<span>def <span class="ident">add_ilp</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the serialized Ilp passed through the request form (encoded as a hexidecimal string).</p>
<p>Returns the ID of the new Ilp.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/add_ilp&#39;, methods=[&#39;POST&#39;])
def add_ilp():
    &#39;&#39;&#39;Add the serialized Ilp passed through the request form (encoded as a hexidecimal string).
    
    Returns the ID of the new Ilp.
    &#39;&#39;&#39;
    new_ilp_serialized : str = request.form[&#39;ilp&#39;]
    if not new_ilp_serialized:
        return FAILURE

    new_ilp = Ilp.deserialize_s(new_ilp_serialized)
    ilp_queue.add(new_ilp)

    logging.debug(f&#34;Added new ilp with ID {new_ilp.get_id()}&#34;)
    return str(new_ilp.get_id())</code></pre>
</details>
</dd>
<dt id="ilpcoin.ilp_queue.ilp_queue.get_ilp_by_id"><code class="name flex">
<span>def <span class="ident">get_ilp_by_id</span></span>(<span>uid)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a hex string serialization if the Ilp with id <code>uid</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/get_ilp_by_id/&lt;uid&gt;&#39;, methods=[&#39;GET&#39;])
def get_ilp_by_id(uid):
    &#39;&#39;&#39;Return a hex string serialization if the Ilp with id `uid`&#39;&#39;&#39;
    logging.debug(&#34;Looking up ilp with id: &#34; + uid)
    result = ilp_queue.lookup_ilp(int(uid))
    return result.serialize_s() if result else ILP_NOT_FOUND</code></pre>
</details>
</dd>
<dt id="ilpcoin.ilp_queue.ilp_queue.get_neighbors"><code class="name flex">
<span>def <span class="ident">get_neighbors</span></span>(<span>n)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a pickled list of n verifier IDs that the queue know about. If
fewer than n verifiers are known, returns all verifiers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/get_neighbors/&lt;n&gt;&#39;, methods=[&#39;GET&#39;])
def get_neighbors(n):
    &#39;&#39;&#39;Returns a pickled list of n verifier IDs that the queue know about. If 
    fewer than n verifiers are known, returns all verifiers.
    &#39;&#39;&#39;
    try: 
        res = sample(ilp_queue.verifiers, n)
    except: 
        res = ilp_queue.verifiers
    logging.debug(f&#34;sending neighbors {res}&#34;)
    return pickle.dumps(res)</code></pre>
</details>
</dd>
<dt id="ilpcoin.ilp_queue.ilp_queue.get_solution_by_id"><code class="name flex">
<span>def <span class="ident">get_solution_by_id</span></span>(<span>uid, tries: int = 3)</span>
</code></dt>
<dd>
<div class="desc"><p>Try <code>tries</code> times to query random verifiers for a solution to Ilp with id <code>uid</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/get_solution_by_id/&lt;uid&gt;&#39;, methods=[&#39;GET&#39;])
def get_solution_by_id(uid, tries : int = 3):
    &#39;&#39;&#39; Try `tries` times to query random verifiers for a solution to Ilp with id `uid`&#39;&#39;&#39;
    for i in range(tries): 
        id = ilp_queue.get_verifier_ip()
        if not id: 
            return NO_VERIFIERS
        r = requests.get(&#34;http://&#34; + (HOST + &#34;:&#34; + str(int(PORT) + int(id))) + &#34;/get_ilp_solution/&#34; + str(uid), timeout=3)
        if r.text: 
            return r.text
    return TIMEOUT</code></pre>
</details>
</dd>
<dt id="ilpcoin.ilp_queue.ilp_queue.get_top_ilp"><code class="name flex">
<span>def <span class="ident">get_top_ilp</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a hex string serialized Ilp on the top of the queue, if available.</p>
<p>Returns ILP_NOT_FOUND on failure.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/get_top_ilp&#39;, methods=[&#39;GET&#39;])
def get_top_ilp():
    &#39;&#39;&#39;Return a hex string serialized Ilp on the top of the queue, if available.
    
    Returns ILP_NOT_FOUND on failure.&#39;&#39;&#39;
    result = ilp_queue.get_top()
    return result.serialize_s() if result else ILP_NOT_FOUND</code></pre>
</details>
</dd>
<dt id="ilpcoin.ilp_queue.ilp_queue.register_verifier"><code class="name flex">
<span>def <span class="ident">register_verifier</span></span>(<span>address)</span>
</code></dt>
<dd>
<div class="desc"><p>Announce to the queue that verifier at <code>address</code> is online</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/register_verifier/&lt;address&gt;&#39;, methods=[&#39;GET&#39;])
def register_verifier(address): 
    &#39;&#39;&#39;Announce to the queue that verifier at `address` is online&#39;&#39;&#39;
    if not address in ilp_queue.verifiers: 
        ilp_queue.add_verifer(address)
    return SUCCESS</code></pre>
</details>
</dd>
<dt id="ilpcoin.ilp_queue.ilp_queue.verify_ilp"><code class="name flex">
<span>def <span class="ident">verify_ilp</span></span>(<span>ilp_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Announce to the queue that you have verified a solution for ilp_id.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@app.route(&#39;/verify_ilp/&lt;ilp_id&gt;&#39;, methods=[&#39;GET&#39;])
def verify_ilp(ilp_id):
    &#39;&#39;&#39;Announce to the queue that you have verified a solution for ilp_id.&#39;&#39;&#39;
    return SUCCESS if ilp_queue.incr_count(ilp_id) else NOT_TOP_ILP</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ilpcoin.ilp_queue.ilp_queue.IlpQueue"><code class="flex name class">
<span>class <span class="ident">IlpQueue</span></span>
<span>(</span><span>initial_verifiers: List[int] = [], generate_random_ilps=True)</span>
</code></dt>
<dd>
<div class="desc"><p>IlpQueue represents the state for a queue of Ilps. </p>
<p>The ilp-queue application is backed by this data structure.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>q</code></strong> :&ensp;<code>queue.Queue</code></dt>
<dd>The underlying Python queue that stores the Ilps.</dd>
<dt><strong><code>top</code></strong> :&ensp;<code>Optional[Ilp]</code></dt>
<dd>The current Ilp at the head of the queue. This is the Ilp currently being solved
by the blockchain.</dd>
<dt><strong><code>count</code></strong> :&ensp;<code>int</code></dt>
<dd>The number of verifiers who report having solved <code>top</code>.</dd>
<dt><strong><code>ilp_history</code></strong> :&ensp;<code>dict[int, Ilp]</code></dt>
<dd>A dictionary of every Ilp that has ever been on the queue, indexed by their uid.</dd>
<dt><strong><code>last_used_uid</code></strong> :&ensp;<code>int</code></dt>
<dd>The most recently assigned uid. ID's are not reused, and this is incremented after each new id is provisioned.</dd>
<dt><strong><code>verifiers</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>The set of verifiers that the queue knows about. Verifiers register with the queue on initialization.</dd>
<dt><strong><code>generate_random_ilps</code></strong> :&ensp;<code>bool</code></dt>
<dd>Set to true if the queue should generate random Ilps to ensure there is always an Ilp available. In
general, this is set to true, but we switch it to false for deterministic unit testing.</dd>
</dl>
<p>Initializes a new IlpQueue.</p>
<p>In the future, this could be written to a database frequently, and restored from the database
on startup.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class IlpQueue:
    &#39;&#39;&#39;IlpQueue represents the state for a queue of Ilps. 
    
    The ilp-queue application is backed by this data structure.

    Attributes
    ----------
    q : queue.Queue
        The underlying Python queue that stores the Ilps. 
    top : Optional[Ilp]
        The current Ilp at the head of the queue. This is the Ilp currently being solved 
        by the blockchain.
    count : int
        The number of verifiers who report having solved `top`. 
    ilp_history : dict[int, Ilp]
        A dictionary of every Ilp that has ever been on the queue, indexed by their uid.
    last_used_uid : int
        The most recently assigned uid. ID&#39;s are not reused, and this is incremented after each new id is provisioned. 
    verifiers : List[int]
        The set of verifiers that the queue knows about. Verifiers register with the queue on initialization.
    generate_random_ilps : bool
        Set to true if the queue should generate random Ilps to ensure there is always an Ilp available. In
        general, this is set to true, but we switch it to false for deterministic unit testing.
    &#39;&#39;&#39;

    def __init__(self, initial_verifiers : List[int] = [], generate_random_ilps = True):
        &#39;&#39;&#39;Initializes a new IlpQueue.
        
        In the future, this could be written to a database frequently, and restored from the database 
        on startup.
        &#39;&#39;&#39;
        self.q = queue.Queue() 
        self.top : Optional[Ilp] = None 
        self.count : int = 0   
        self.ilp_history : dict[int, Ilp] = {} 
        self.last_used_uid = 0 
        self.verifiers = initial_verifiers
        self._last_used_verifier = 0 # used the ensure different subsets of verifiers are given when queue is used as a DNS
        self.generate_random_ilps = generate_random_ilps
        if self.generate_random_ilps: 
            self.__add_random_ilp()

    def add(self, ilp : Ilp) -&gt; int:
        &#39;&#39;&#39;Add an Ilp (see `Ilp`for representation) to the back of the queue.&#39;&#39;&#39;
        self.last_used_uid += 1
        ilp.set_id(self.last_used_uid)
        self.q.put(ilp)
        self.ilp_history[ilp.get_id()] = ilp
        if not self.top: 
            self.top = self.q.get()
            logging.debug(f&#34;Top ILP has ID {self.top.get_id()}&#34;)
        return ilp.get_id()
    
    # Return a verifier ip, different from the last time
    def get_verifier_ip(self) -&gt; Optional[int]: 
        &#39;&#39;&#39;Return the id of a ranndom verifier known to be on the network. 
        
        Cycles through verifiers to avoid repetition.
        &#39;&#39;&#39;
        
        if not self.verifiers: 
            return None

        self._last_used_verifier += 1

        return self.verifiers[self._last_used_verifier % len(self.verifiers)]

    def add_verifer(self, ip): 
        &#39;&#39;&#39;Make the queue aware of a new verifier, with address `ip`&#39;&#39;&#39;
        self.verifiers.append(ip)

    def get_top(self) -&gt; Optional[Ilp]:
        &#39;&#39;&#39;Return the Ilp the blockchain is currently working on. None otherwise.&#39;&#39;&#39;
        return self.top

    def lookup_ilp(self, id : int) -&gt; Optional[Ilp]:
        &#39;&#39;&#39;Return the ilp matching `id`.&#39;&#39;&#39;
        try:
            return self.ilp_history[id]
        except:
            return None
    
    # Add a random Ilp to the queue
    def __add_random_ilp(self): 
        self.add(random_knapsack())

    # Increment the queue to the next element; called when enough verifiers have 
    # checked the solution. 
    def __complete_item(self) -&gt; None:
        logging.debug(&#34;Ilp with id &#34; + str(self.top.get_id()) + &#34; is popped from queue.&#34;) 

        if not self.q.empty():
            self.top = self.q.get()
        else:
            if self.generate_random_ilps: 
                self.__add_random_ilp()
                self.top = self.q.get()
            else: 
                self.top = None

        self.count = 0

    def incr_count(self, uid : int) -&gt; bool:
        &#39;&#39;&#39;Called when a verifier tells the queue that it has solved the top ilp. 
        
        Increments count, and cycles to next Ilp if necessary. 
        &#39;&#39;&#39;
        if not self.get_top():
            return False

        if (self.get_top().get_id() != int(uid)):
            logging.debug(f&#34;Verifying ILP w ID {uid} but top of the queue is {self.get_top().get_id()}&#34;)
            return False

        self.count += 1
        if(self.count &gt;= ilpcoin.common.constants.VERIFIERS_NEEDED):
            self.__complete_item()
        logging.debug(f&#34;Registering solution for ilp with id {uid}&#34;)
        return True</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ilpcoin.ilp_queue.ilp_queue.IlpQueue.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, ilp: <a title="ilpcoin.common.ilp.Ilp" href="../common/ilp.html#ilpcoin.common.ilp.Ilp">Ilp</a>) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Add an Ilp (see <code>Ilp</code>for representation) to the back of the queue.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, ilp : Ilp) -&gt; int:
    &#39;&#39;&#39;Add an Ilp (see `Ilp`for representation) to the back of the queue.&#39;&#39;&#39;
    self.last_used_uid += 1
    ilp.set_id(self.last_used_uid)
    self.q.put(ilp)
    self.ilp_history[ilp.get_id()] = ilp
    if not self.top: 
        self.top = self.q.get()
        logging.debug(f&#34;Top ILP has ID {self.top.get_id()}&#34;)
    return ilp.get_id()</code></pre>
</details>
</dd>
<dt id="ilpcoin.ilp_queue.ilp_queue.IlpQueue.add_verifer"><code class="name flex">
<span>def <span class="ident">add_verifer</span></span>(<span>self, ip)</span>
</code></dt>
<dd>
<div class="desc"><p>Make the queue aware of a new verifier, with address <code>ip</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_verifer(self, ip): 
    &#39;&#39;&#39;Make the queue aware of a new verifier, with address `ip`&#39;&#39;&#39;
    self.verifiers.append(ip)</code></pre>
</details>
</dd>
<dt id="ilpcoin.ilp_queue.ilp_queue.IlpQueue.get_top"><code class="name flex">
<span>def <span class="ident">get_top</span></span>(<span>self) ‑> Optional[<a title="ilpcoin.common.ilp.Ilp" href="../common/ilp.html#ilpcoin.common.ilp.Ilp">Ilp</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the Ilp the blockchain is currently working on. None otherwise.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_top(self) -&gt; Optional[Ilp]:
    &#39;&#39;&#39;Return the Ilp the blockchain is currently working on. None otherwise.&#39;&#39;&#39;
    return self.top</code></pre>
</details>
</dd>
<dt id="ilpcoin.ilp_queue.ilp_queue.IlpQueue.get_verifier_ip"><code class="name flex">
<span>def <span class="ident">get_verifier_ip</span></span>(<span>self) ‑> Optional[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the id of a ranndom verifier known to be on the network. </p>
<p>Cycles through verifiers to avoid repetition.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_verifier_ip(self) -&gt; Optional[int]: 
    &#39;&#39;&#39;Return the id of a ranndom verifier known to be on the network. 
    
    Cycles through verifiers to avoid repetition.
    &#39;&#39;&#39;
    
    if not self.verifiers: 
        return None

    self._last_used_verifier += 1

    return self.verifiers[self._last_used_verifier % len(self.verifiers)]</code></pre>
</details>
</dd>
<dt id="ilpcoin.ilp_queue.ilp_queue.IlpQueue.incr_count"><code class="name flex">
<span>def <span class="ident">incr_count</span></span>(<span>self, uid: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Called when a verifier tells the queue that it has solved the top ilp. </p>
<p>Increments count, and cycles to next Ilp if necessary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def incr_count(self, uid : int) -&gt; bool:
    &#39;&#39;&#39;Called when a verifier tells the queue that it has solved the top ilp. 
    
    Increments count, and cycles to next Ilp if necessary. 
    &#39;&#39;&#39;
    if not self.get_top():
        return False

    if (self.get_top().get_id() != int(uid)):
        logging.debug(f&#34;Verifying ILP w ID {uid} but top of the queue is {self.get_top().get_id()}&#34;)
        return False

    self.count += 1
    if(self.count &gt;= ilpcoin.common.constants.VERIFIERS_NEEDED):
        self.__complete_item()
    logging.debug(f&#34;Registering solution for ilp with id {uid}&#34;)
    return True</code></pre>
</details>
</dd>
<dt id="ilpcoin.ilp_queue.ilp_queue.IlpQueue.lookup_ilp"><code class="name flex">
<span>def <span class="ident">lookup_ilp</span></span>(<span>self, id: int) ‑> Optional[<a title="ilpcoin.common.ilp.Ilp" href="../common/ilp.html#ilpcoin.common.ilp.Ilp">Ilp</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the ilp matching <code>id</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lookup_ilp(self, id : int) -&gt; Optional[Ilp]:
    &#39;&#39;&#39;Return the ilp matching `id`.&#39;&#39;&#39;
    try:
        return self.ilp_history[id]
    except:
        return None</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ilpcoin.ilp_queue" href="index.html">ilpcoin.ilp_queue</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="ilpcoin.ilp_queue.ilp_queue.add_ilp" href="#ilpcoin.ilp_queue.ilp_queue.add_ilp">add_ilp</a></code></li>
<li><code><a title="ilpcoin.ilp_queue.ilp_queue.get_ilp_by_id" href="#ilpcoin.ilp_queue.ilp_queue.get_ilp_by_id">get_ilp_by_id</a></code></li>
<li><code><a title="ilpcoin.ilp_queue.ilp_queue.get_neighbors" href="#ilpcoin.ilp_queue.ilp_queue.get_neighbors">get_neighbors</a></code></li>
<li><code><a title="ilpcoin.ilp_queue.ilp_queue.get_solution_by_id" href="#ilpcoin.ilp_queue.ilp_queue.get_solution_by_id">get_solution_by_id</a></code></li>
<li><code><a title="ilpcoin.ilp_queue.ilp_queue.get_top_ilp" href="#ilpcoin.ilp_queue.ilp_queue.get_top_ilp">get_top_ilp</a></code></li>
<li><code><a title="ilpcoin.ilp_queue.ilp_queue.register_verifier" href="#ilpcoin.ilp_queue.ilp_queue.register_verifier">register_verifier</a></code></li>
<li><code><a title="ilpcoin.ilp_queue.ilp_queue.verify_ilp" href="#ilpcoin.ilp_queue.ilp_queue.verify_ilp">verify_ilp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ilpcoin.ilp_queue.ilp_queue.IlpQueue" href="#ilpcoin.ilp_queue.ilp_queue.IlpQueue">IlpQueue</a></code></h4>
<ul class="two-column">
<li><code><a title="ilpcoin.ilp_queue.ilp_queue.IlpQueue.add" href="#ilpcoin.ilp_queue.ilp_queue.IlpQueue.add">add</a></code></li>
<li><code><a title="ilpcoin.ilp_queue.ilp_queue.IlpQueue.add_verifer" href="#ilpcoin.ilp_queue.ilp_queue.IlpQueue.add_verifer">add_verifer</a></code></li>
<li><code><a title="ilpcoin.ilp_queue.ilp_queue.IlpQueue.get_top" href="#ilpcoin.ilp_queue.ilp_queue.IlpQueue.get_top">get_top</a></code></li>
<li><code><a title="ilpcoin.ilp_queue.ilp_queue.IlpQueue.get_verifier_ip" href="#ilpcoin.ilp_queue.ilp_queue.IlpQueue.get_verifier_ip">get_verifier_ip</a></code></li>
<li><code><a title="ilpcoin.ilp_queue.ilp_queue.IlpQueue.incr_count" href="#ilpcoin.ilp_queue.ilp_queue.IlpQueue.incr_count">incr_count</a></code></li>
<li><code><a title="ilpcoin.ilp_queue.ilp_queue.IlpQueue.lookup_ilp" href="#ilpcoin.ilp_queue.ilp_queue.IlpQueue.lookup_ilp">lookup_ilp</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>