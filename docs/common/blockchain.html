<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>ilpcoin.common.blockchain API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ilpcoin.common.blockchain</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!usr/bin/env python3

import hashlib
from typing import List, Optional
from ilpcoin.common.ilp import *
from ilpcoin.common.constants import *
import requests
import logging

class BadTransactionError(Exception):
    pass

class BadBlockError(Exception):
    pass

class Transaction:

    &#39;&#39;&#39;Represents a transaction, a group of which comprise a block. 

    Attributes
    ----------
    sender : string
        The user who sends this transaction.
    receiver : string
        The receiver of the transaction. 
    amount : int
        The amount of ilpcoin transferred. 
    &#39;&#39;&#39;

    def __init__(self, sender:str=&#39;&#39;, receiver: str=&#39;&#39;, amount: int=0):
        &#39;&#39;&#39;Initializes a transaction.&#39;&#39;&#39;
        self.sender = sender
        self.receiver = receiver
        self.amount = amount

    def __eq__(self, other:&#39;Transaction&#39;):
        check = self.sender == other.sender
        check &amp;= self.receiver == other.receiver
        check &amp;= self.amount == other.amount
        return check
        
    def hash(self) -&gt; str:
        &#39;&#39;&#39;Generate the sha256 hash of this transaction.&#39;&#39;&#39;
        to_hash = bytes(self.sender+self.receiver+str(self.amount), &#39;utf-8&#39;)
        return hashlib.sha256(to_hash).hexdigest()
    
    def serialize(self) -&gt; bytes:
        &#39;&#39;&#39;Serialize this transaction to bytes, using pickle.&#39;&#39;&#39;
        return pickle.dumps(self)
    
    @classmethod
    def deserialize(cls, data: bytes):
        &#39;&#39;&#39;Inverse of serialize. Returns a Transaction.&#39;&#39;&#39;
        return pickle.loads(data)

class Block:

    &#39;&#39;&#39;Encapsulates all information about a block in the chain

    Attributes
    ----------
    transactions : List[Transaction]
        The transactions in the block.
    prev_hash : str
        The sha256 hash of the previous block in the chain. 
    ILP : int 
        The global uid of the Ilp associated with this block. 
    ILP_solution : Optional[IlpSolution]
        The solution to the ILP. Note that, unlike the ILP, the entire solution object is stored on the blockchain. 
    nonce : int 
        The nonce discovered to solve this block.
    testing : bool 
        Set to false, except when running the test suite. 
    &#39;&#39;&#39;
    
    def __init__(self, transactions: List[Transaction]=[], prev_hash: str=&#39;&#39;, nonce:int = 0, 
    ILP: int=0, ILP_solution: Optional[IlpSolution]=None, testing=False):
        &#39;&#39;&#39;Initialize a new block.&#39;&#39;&#39;
        self.transactions: List[Transaction] = transactions
        self.prev_hash: str = prev_hash
        self.ILP: int = ILP
        self.ILP_solution: Optional[IlpSolution] = ILP_solution
        self.nonce: int = nonce
        self.testing = testing
    
        prev_hash, nonce, ILP, ILP_solution

    def __eq__(self, other: &#39;Block&#39;):
        &#39;&#39;&#39;For testing, it is necessary to be able to compare blocks.&#39;&#39;&#39;
        check: bool = True
        for (t1, t2) in zip(self.transactions, other.transactions):
            check &amp;= t1 == t2
        check &amp;= self.prev_hash == other.prev_hash
        check &amp;= self.ILP == other.ILP
        check &amp;= self.ILP_solution.variable_results == other.ILP_solution.variable_results
        check &amp;= self.nonce == other.nonce
        return check

    def serialize(self) -&gt; bytes:
        &#39;&#39;&#39;Serialize this block to bytes, using pickle.&#39;&#39;&#39;
        return pickle.dumps(self)

    @classmethod
    def deserialize(cls, data: bytes) -&gt; &#39;Block&#39;:
        &#39;&#39;&#39;Inverse of serialize. Returns a Block.&#39;&#39;&#39;
        return pickle.loads(data)
    
    def hash(self) -&gt; str:
        &#39;&#39;&#39;Generate the sha256 hash of this block.&#39;&#39;&#39;
        to_hash = self.ILP_solution.serialize() + bytes(str(self.nonce) + self.prev_hash, &#39;utf-8&#39;)
        for t in self.transactions:
            to_hash += t.serialize()
        return hashlib.sha256(to_hash).hexdigest()
    
    def validate_top_of_queue(self):
        &#39;&#39;&#39;Inform the queue that the Ilp ahs been solved, and return true if the queue accepts the solution. 

        The queue will reject the solution if the Ilp is stale, and the chain has moved on to solving subsequent Ilps.&#39;&#39;&#39;
        r = requests.get(QUEUE_HOST + &#34;:&#34; + str(QUEUE_PORT) + &#34;/get_top_ilp&#34;)
        top_ILP = Ilp.deserialize(r.content)
        return self.ILP == top_ILP.get_id()

    def validate_block(self, previous: Optional[&#39;Block&#39;], hardness: int) -&gt; bool:
        &#39;&#39;&#39;The primary verification routine. Uses the previous block to check that the hashes are valid, 
        the transactions are valid, and the solution solves the Ilp.

        This is used by both miners and verifiers to validate blocks.
        &#39;&#39;&#39;
        check: bool = self.validate_nonce(hardness)

        # check that the previous_hash is correct
        if previous:
            check &amp;= previous.hash() == self.prev_hash 
            logging.debug(f&#34;Previous hash was correct? {check}&#34;)
        
        if not self.testing:
            r = requests.get(&#34;http://&#34; + QUEUE_HOST + &#34;:&#34; + str(QUEUE_PORT) + &#34;/&#34; + &#39;get_ilp_by_id/&#39; + str(self.ILP))
            if r.text == ILP_NOT_FOUND:
                logging.debug(f&#34;ILP_NOT_FOUND id {self.ILP}&#34;)
                return False 
            else:
                full_ILP = Ilp.deserialize_s(r.text)
                if self.ILP_solution:
                    check &amp;= full_ILP.check(self.ILP_solution)
        if self.transactions != []:
            check &amp;= self.transactions[0].sender == self.transactions[0].receiver
            check &amp;= self.transactions[0].amount == REWARD 
        
        logging.debug(f&#34;Block successfully validated? {check}&#34;)
        return check
    
    def validate_nonce(self, hardness: int) -&gt; bool:
        &#39;&#39;&#39;Ensure that the nonce solves the hash puzzle for this block. Both miners and verifiers should use this method to validate a nonce.&#39;&#39;&#39;
        try:
            return int(self.hash()[len(self.hash()) - hardness:]) == 0
        except:
            logging.debug(&#34;Found a bad nonce&#34;)
            return False
    
    def set_nonce(self, nonce:int) -&gt; None:
        &#39;&#39;&#39;Used by miners to set the nonce for this block. &#39;&#39;&#39;
        self.nonce = nonce


class Blockchain:

    &#39;&#39;&#39;A blockchain is a list of blocks, equipped with logic for validating invariants on them. 
    
    See individual methods for details.
    &#39;&#39;&#39;

    def __init__(self, blocks: List[Block]=[]):
        self.blockchain: List[Block] = blocks
    
    def __eq__(self, other: &#39;Blockchain&#39;):
        check: bool = True
        for (b1, b2) in zip(self.blockchain, other.blockchain):
            check &amp;= b1 == b2
        return check
    
    def serialize(self) -&gt; bytes:
        &#39;&#39;&#39;Serialize this blockchain to bytes, using pickle.&#39;&#39;&#39;
        return pickle.dumps(self)
    
    @classmethod
    def deserialize(cls, data:bytes):
        &#39;&#39;&#39;The inverse of serialize. Creates a Blockchain.&#39;&#39;&#39;
        return pickle.loads(data)
    
    def get_top(self) -&gt; Optional[Block]:
        &#39;&#39;&#39;Get the block at the head of the blockchain, or None of the chain is empty. &#39;&#39;&#39;
        if self.blockchain == []:
            return None
        else:
            return self.blockchain[len(self.blockchain) - 1]
    
    def add_block(self, block: Block):
        &#39;&#39;&#39;Attach a new block to this blockchain. Note: No verification is performed on add.&#39;&#39;&#39;
        self.blockchain.append(block)
    
    def get_value_by_user(self, user: str, block_index: int, trans_index: int) -&gt; int:
        &#39;&#39;&#39;Replay the blockchain up to block_index:trans_index to determine how much ilpcoin the user currently has.&#39;&#39;&#39;
        amount = 0

        # pool up all the money owned by this sender
        for block in self.blockchain[:block_index]:

            # handle transaction fee
            if user == block.transactions[0].sender:
                amount += block.transactions[0].amount

            for t in block.transactions[1:trans_index]:
                if t.sender == user:
                    amount -= t.amount
                if t.receiver == user:
                    amount += t.amount
        return amount
    
    def verify_transaction(self, transaction: Transaction, block_index: int, trans_index: int) -&gt; bool:
        &#39;&#39;&#39;Verify that transaction on this chain at block_index:trans_index does not double spend.&#39;&#39;&#39;
        amount = self.get_value_by_user(transaction.sender, block_index, trans_index)
        return not (amount &lt; transaction.amount)
    
    def get_len(self) -&gt; int:
        &#39;&#39;&#39;Return the number of blocks in the blockchain.&#39;&#39;&#39;
        return len(self.blockchain)
    
    def get_solution_by_id(self, id:int) -&gt;  Optional[IlpSolution]:
        &#39;&#39;&#39;Check if a solution for the ilp with id `id` exists on the chain, and return it if it does. 
        
        This is used by the queue to service client requests.
        &#39;&#39;&#39;
        for b in self.blockchain:
            if int(b.ILP) == int(id):
                return b.ILP_solution
        return None
    
    def verify_blockchain(self) -&gt; bool:
        &#39;&#39;&#39;Verify the integrity of the blockciain. 

        Replays the entire chain for consistency and valid proof of work: both nonces and Ilp solutions.
        &#39;&#39;&#39;
        previous = None
        for i in range(len(self.blockchain)):
            if not self.blockchain[i].validate_block(previous, HARDNESS):
                return False 
            previous = self.blockchain[i]
            
            # skip genesis transaction - that&#39;s a blockwide property
            for t in range(1, len(self.blockchain[i].transactions[1:])):
                if not self.verify_transaction(self.blockchain[i].transactions[t], i, t):
                    return False 
        return True 

    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ilpcoin.common.blockchain.BadBlockError"><code class="flex name class">
<span>class <span class="ident">BadBlockError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BadBlockError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="ilpcoin.common.blockchain.BadTransactionError"><code class="flex name class">
<span>class <span class="ident">BadTransactionError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BadTransactionError(Exception):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="ilpcoin.common.blockchain.Block"><code class="flex name class">
<span>class <span class="ident">Block</span></span>
<span>(</span><span>transactions: List[<a title="ilpcoin.common.blockchain.Transaction" href="#ilpcoin.common.blockchain.Transaction">Transaction</a>] = [], prev_hash: str = '', nonce: int = 0, ILP: int = 0, ILP_solution: Optional[<a title="ilpcoin.common.ilp.IlpSolution" href="ilp.html#ilpcoin.common.ilp.IlpSolution">IlpSolution</a>] = None, testing=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Encapsulates all information about a block in the chain</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>transactions</code></strong> :&ensp;<code>List[<a title="ilpcoin.common.blockchain.Transaction" href="#ilpcoin.common.blockchain.Transaction">Transaction</a>]</code></dt>
<dd>The transactions in the block.</dd>
<dt><strong><code>prev_hash</code></strong> :&ensp;<code>str</code></dt>
<dd>The sha256 hash of the previous block in the chain.</dd>
<dt><strong><code>ILP</code></strong> :&ensp;<code>int </code></dt>
<dd>The global uid of the Ilp associated with this block.</dd>
<dt><strong><code>ILP_solution</code></strong> :&ensp;<code>Optional[IlpSolution]</code></dt>
<dd>The solution to the ILP. Note that, unlike the ILP, the entire solution object is stored on the blockchain.</dd>
<dt><strong><code>nonce</code></strong> :&ensp;<code>int </code></dt>
<dd>The nonce discovered to solve this block.</dd>
<dt><strong><code>testing</code></strong> :&ensp;<code>bool </code></dt>
<dd>Set to false, except when running the test suite.</dd>
</dl>
<p>Initialize a new block.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Block:

    &#39;&#39;&#39;Encapsulates all information about a block in the chain

    Attributes
    ----------
    transactions : List[Transaction]
        The transactions in the block.
    prev_hash : str
        The sha256 hash of the previous block in the chain. 
    ILP : int 
        The global uid of the Ilp associated with this block. 
    ILP_solution : Optional[IlpSolution]
        The solution to the ILP. Note that, unlike the ILP, the entire solution object is stored on the blockchain. 
    nonce : int 
        The nonce discovered to solve this block.
    testing : bool 
        Set to false, except when running the test suite. 
    &#39;&#39;&#39;
    
    def __init__(self, transactions: List[Transaction]=[], prev_hash: str=&#39;&#39;, nonce:int = 0, 
    ILP: int=0, ILP_solution: Optional[IlpSolution]=None, testing=False):
        &#39;&#39;&#39;Initialize a new block.&#39;&#39;&#39;
        self.transactions: List[Transaction] = transactions
        self.prev_hash: str = prev_hash
        self.ILP: int = ILP
        self.ILP_solution: Optional[IlpSolution] = ILP_solution
        self.nonce: int = nonce
        self.testing = testing
    
        prev_hash, nonce, ILP, ILP_solution

    def __eq__(self, other: &#39;Block&#39;):
        &#39;&#39;&#39;For testing, it is necessary to be able to compare blocks.&#39;&#39;&#39;
        check: bool = True
        for (t1, t2) in zip(self.transactions, other.transactions):
            check &amp;= t1 == t2
        check &amp;= self.prev_hash == other.prev_hash
        check &amp;= self.ILP == other.ILP
        check &amp;= self.ILP_solution.variable_results == other.ILP_solution.variable_results
        check &amp;= self.nonce == other.nonce
        return check

    def serialize(self) -&gt; bytes:
        &#39;&#39;&#39;Serialize this block to bytes, using pickle.&#39;&#39;&#39;
        return pickle.dumps(self)

    @classmethod
    def deserialize(cls, data: bytes) -&gt; &#39;Block&#39;:
        &#39;&#39;&#39;Inverse of serialize. Returns a Block.&#39;&#39;&#39;
        return pickle.loads(data)
    
    def hash(self) -&gt; str:
        &#39;&#39;&#39;Generate the sha256 hash of this block.&#39;&#39;&#39;
        to_hash = self.ILP_solution.serialize() + bytes(str(self.nonce) + self.prev_hash, &#39;utf-8&#39;)
        for t in self.transactions:
            to_hash += t.serialize()
        return hashlib.sha256(to_hash).hexdigest()
    
    def validate_top_of_queue(self):
        &#39;&#39;&#39;Inform the queue that the Ilp ahs been solved, and return true if the queue accepts the solution. 

        The queue will reject the solution if the Ilp is stale, and the chain has moved on to solving subsequent Ilps.&#39;&#39;&#39;
        r = requests.get(QUEUE_HOST + &#34;:&#34; + str(QUEUE_PORT) + &#34;/get_top_ilp&#34;)
        top_ILP = Ilp.deserialize(r.content)
        return self.ILP == top_ILP.get_id()

    def validate_block(self, previous: Optional[&#39;Block&#39;], hardness: int) -&gt; bool:
        &#39;&#39;&#39;The primary verification routine. Uses the previous block to check that the hashes are valid, 
        the transactions are valid, and the solution solves the Ilp.

        This is used by both miners and verifiers to validate blocks.
        &#39;&#39;&#39;
        check: bool = self.validate_nonce(hardness)

        # check that the previous_hash is correct
        if previous:
            check &amp;= previous.hash() == self.prev_hash 
            logging.debug(f&#34;Previous hash was correct? {check}&#34;)
        
        if not self.testing:
            r = requests.get(&#34;http://&#34; + QUEUE_HOST + &#34;:&#34; + str(QUEUE_PORT) + &#34;/&#34; + &#39;get_ilp_by_id/&#39; + str(self.ILP))
            if r.text == ILP_NOT_FOUND:
                logging.debug(f&#34;ILP_NOT_FOUND id {self.ILP}&#34;)
                return False 
            else:
                full_ILP = Ilp.deserialize_s(r.text)
                if self.ILP_solution:
                    check &amp;= full_ILP.check(self.ILP_solution)
        if self.transactions != []:
            check &amp;= self.transactions[0].sender == self.transactions[0].receiver
            check &amp;= self.transactions[0].amount == REWARD 
        
        logging.debug(f&#34;Block successfully validated? {check}&#34;)
        return check
    
    def validate_nonce(self, hardness: int) -&gt; bool:
        &#39;&#39;&#39;Ensure that the nonce solves the hash puzzle for this block. Both miners and verifiers should use this method to validate a nonce.&#39;&#39;&#39;
        try:
            return int(self.hash()[len(self.hash()) - hardness:]) == 0
        except:
            logging.debug(&#34;Found a bad nonce&#34;)
            return False
    
    def set_nonce(self, nonce:int) -&gt; None:
        &#39;&#39;&#39;Used by miners to set the nonce for this block. &#39;&#39;&#39;
        self.nonce = nonce</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="ilpcoin.common.blockchain.Block.deserialize"><code class="name flex">
<span>def <span class="ident">deserialize</span></span>(<span>data: bytes) ‑> <a title="ilpcoin.common.blockchain.Block" href="#ilpcoin.common.blockchain.Block">Block</a></span>
</code></dt>
<dd>
<div class="desc"><p>Inverse of serialize. Returns a Block.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def deserialize(cls, data: bytes) -&gt; &#39;Block&#39;:
    &#39;&#39;&#39;Inverse of serialize. Returns a Block.&#39;&#39;&#39;
    return pickle.loads(data)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ilpcoin.common.blockchain.Block.hash"><code class="name flex">
<span>def <span class="ident">hash</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the sha256 hash of this block.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hash(self) -&gt; str:
    &#39;&#39;&#39;Generate the sha256 hash of this block.&#39;&#39;&#39;
    to_hash = self.ILP_solution.serialize() + bytes(str(self.nonce) + self.prev_hash, &#39;utf-8&#39;)
    for t in self.transactions:
        to_hash += t.serialize()
    return hashlib.sha256(to_hash).hexdigest()</code></pre>
</details>
</dd>
<dt id="ilpcoin.common.blockchain.Block.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize this block to bytes, using pickle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self) -&gt; bytes:
    &#39;&#39;&#39;Serialize this block to bytes, using pickle.&#39;&#39;&#39;
    return pickle.dumps(self)</code></pre>
</details>
</dd>
<dt id="ilpcoin.common.blockchain.Block.set_nonce"><code class="name flex">
<span>def <span class="ident">set_nonce</span></span>(<span>self, nonce: int) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Used by miners to set the nonce for this block.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_nonce(self, nonce:int) -&gt; None:
    &#39;&#39;&#39;Used by miners to set the nonce for this block. &#39;&#39;&#39;
    self.nonce = nonce</code></pre>
</details>
</dd>
<dt id="ilpcoin.common.blockchain.Block.validate_block"><code class="name flex">
<span>def <span class="ident">validate_block</span></span>(<span>self, previous: Optional[ForwardRef('<a title="ilpcoin.common.blockchain.Block" href="#ilpcoin.common.blockchain.Block">Block</a>')], hardness: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>The primary verification routine. Uses the previous block to check that the hashes are valid,
the transactions are valid, and the solution solves the Ilp.</p>
<p>This is used by both miners and verifiers to validate blocks.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_block(self, previous: Optional[&#39;Block&#39;], hardness: int) -&gt; bool:
    &#39;&#39;&#39;The primary verification routine. Uses the previous block to check that the hashes are valid, 
    the transactions are valid, and the solution solves the Ilp.

    This is used by both miners and verifiers to validate blocks.
    &#39;&#39;&#39;
    check: bool = self.validate_nonce(hardness)

    # check that the previous_hash is correct
    if previous:
        check &amp;= previous.hash() == self.prev_hash 
        logging.debug(f&#34;Previous hash was correct? {check}&#34;)
    
    if not self.testing:
        r = requests.get(&#34;http://&#34; + QUEUE_HOST + &#34;:&#34; + str(QUEUE_PORT) + &#34;/&#34; + &#39;get_ilp_by_id/&#39; + str(self.ILP))
        if r.text == ILP_NOT_FOUND:
            logging.debug(f&#34;ILP_NOT_FOUND id {self.ILP}&#34;)
            return False 
        else:
            full_ILP = Ilp.deserialize_s(r.text)
            if self.ILP_solution:
                check &amp;= full_ILP.check(self.ILP_solution)
    if self.transactions != []:
        check &amp;= self.transactions[0].sender == self.transactions[0].receiver
        check &amp;= self.transactions[0].amount == REWARD 
    
    logging.debug(f&#34;Block successfully validated? {check}&#34;)
    return check</code></pre>
</details>
</dd>
<dt id="ilpcoin.common.blockchain.Block.validate_nonce"><code class="name flex">
<span>def <span class="ident">validate_nonce</span></span>(<span>self, hardness: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure that the nonce solves the hash puzzle for this block. Both miners and verifiers should use this method to validate a nonce.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_nonce(self, hardness: int) -&gt; bool:
    &#39;&#39;&#39;Ensure that the nonce solves the hash puzzle for this block. Both miners and verifiers should use this method to validate a nonce.&#39;&#39;&#39;
    try:
        return int(self.hash()[len(self.hash()) - hardness:]) == 0
    except:
        logging.debug(&#34;Found a bad nonce&#34;)
        return False</code></pre>
</details>
</dd>
<dt id="ilpcoin.common.blockchain.Block.validate_top_of_queue"><code class="name flex">
<span>def <span class="ident">validate_top_of_queue</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Inform the queue that the Ilp ahs been solved, and return true if the queue accepts the solution. </p>
<p>The queue will reject the solution if the Ilp is stale, and the chain has moved on to solving subsequent Ilps.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_top_of_queue(self):
    &#39;&#39;&#39;Inform the queue that the Ilp ahs been solved, and return true if the queue accepts the solution. 

    The queue will reject the solution if the Ilp is stale, and the chain has moved on to solving subsequent Ilps.&#39;&#39;&#39;
    r = requests.get(QUEUE_HOST + &#34;:&#34; + str(QUEUE_PORT) + &#34;/get_top_ilp&#34;)
    top_ILP = Ilp.deserialize(r.content)
    return self.ILP == top_ILP.get_id()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ilpcoin.common.blockchain.Blockchain"><code class="flex name class">
<span>class <span class="ident">Blockchain</span></span>
<span>(</span><span>blocks: List[<a title="ilpcoin.common.blockchain.Block" href="#ilpcoin.common.blockchain.Block">Block</a>] = [])</span>
</code></dt>
<dd>
<div class="desc"><p>A blockchain is a list of blocks, equipped with logic for validating invariants on them. </p>
<p>See individual methods for details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Blockchain:

    &#39;&#39;&#39;A blockchain is a list of blocks, equipped with logic for validating invariants on them. 
    
    See individual methods for details.
    &#39;&#39;&#39;

    def __init__(self, blocks: List[Block]=[]):
        self.blockchain: List[Block] = blocks
    
    def __eq__(self, other: &#39;Blockchain&#39;):
        check: bool = True
        for (b1, b2) in zip(self.blockchain, other.blockchain):
            check &amp;= b1 == b2
        return check
    
    def serialize(self) -&gt; bytes:
        &#39;&#39;&#39;Serialize this blockchain to bytes, using pickle.&#39;&#39;&#39;
        return pickle.dumps(self)
    
    @classmethod
    def deserialize(cls, data:bytes):
        &#39;&#39;&#39;The inverse of serialize. Creates a Blockchain.&#39;&#39;&#39;
        return pickle.loads(data)
    
    def get_top(self) -&gt; Optional[Block]:
        &#39;&#39;&#39;Get the block at the head of the blockchain, or None of the chain is empty. &#39;&#39;&#39;
        if self.blockchain == []:
            return None
        else:
            return self.blockchain[len(self.blockchain) - 1]
    
    def add_block(self, block: Block):
        &#39;&#39;&#39;Attach a new block to this blockchain. Note: No verification is performed on add.&#39;&#39;&#39;
        self.blockchain.append(block)
    
    def get_value_by_user(self, user: str, block_index: int, trans_index: int) -&gt; int:
        &#39;&#39;&#39;Replay the blockchain up to block_index:trans_index to determine how much ilpcoin the user currently has.&#39;&#39;&#39;
        amount = 0

        # pool up all the money owned by this sender
        for block in self.blockchain[:block_index]:

            # handle transaction fee
            if user == block.transactions[0].sender:
                amount += block.transactions[0].amount

            for t in block.transactions[1:trans_index]:
                if t.sender == user:
                    amount -= t.amount
                if t.receiver == user:
                    amount += t.amount
        return amount
    
    def verify_transaction(self, transaction: Transaction, block_index: int, trans_index: int) -&gt; bool:
        &#39;&#39;&#39;Verify that transaction on this chain at block_index:trans_index does not double spend.&#39;&#39;&#39;
        amount = self.get_value_by_user(transaction.sender, block_index, trans_index)
        return not (amount &lt; transaction.amount)
    
    def get_len(self) -&gt; int:
        &#39;&#39;&#39;Return the number of blocks in the blockchain.&#39;&#39;&#39;
        return len(self.blockchain)
    
    def get_solution_by_id(self, id:int) -&gt;  Optional[IlpSolution]:
        &#39;&#39;&#39;Check if a solution for the ilp with id `id` exists on the chain, and return it if it does. 
        
        This is used by the queue to service client requests.
        &#39;&#39;&#39;
        for b in self.blockchain:
            if int(b.ILP) == int(id):
                return b.ILP_solution
        return None
    
    def verify_blockchain(self) -&gt; bool:
        &#39;&#39;&#39;Verify the integrity of the blockciain. 

        Replays the entire chain for consistency and valid proof of work: both nonces and Ilp solutions.
        &#39;&#39;&#39;
        previous = None
        for i in range(len(self.blockchain)):
            if not self.blockchain[i].validate_block(previous, HARDNESS):
                return False 
            previous = self.blockchain[i]
            
            # skip genesis transaction - that&#39;s a blockwide property
            for t in range(1, len(self.blockchain[i].transactions[1:])):
                if not self.verify_transaction(self.blockchain[i].transactions[t], i, t):
                    return False 
        return True </code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="ilpcoin.common.blockchain.Blockchain.deserialize"><code class="name flex">
<span>def <span class="ident">deserialize</span></span>(<span>data: bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>The inverse of serialize. Creates a Blockchain.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def deserialize(cls, data:bytes):
    &#39;&#39;&#39;The inverse of serialize. Creates a Blockchain.&#39;&#39;&#39;
    return pickle.loads(data)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ilpcoin.common.blockchain.Blockchain.add_block"><code class="name flex">
<span>def <span class="ident">add_block</span></span>(<span>self, block: <a title="ilpcoin.common.blockchain.Block" href="#ilpcoin.common.blockchain.Block">Block</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Attach a new block to this blockchain. Note: No verification is performed on add.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_block(self, block: Block):
    &#39;&#39;&#39;Attach a new block to this blockchain. Note: No verification is performed on add.&#39;&#39;&#39;
    self.blockchain.append(block)</code></pre>
</details>
</dd>
<dt id="ilpcoin.common.blockchain.Blockchain.get_len"><code class="name flex">
<span>def <span class="ident">get_len</span></span>(<span>self) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Return the number of blocks in the blockchain.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_len(self) -&gt; int:
    &#39;&#39;&#39;Return the number of blocks in the blockchain.&#39;&#39;&#39;
    return len(self.blockchain)</code></pre>
</details>
</dd>
<dt id="ilpcoin.common.blockchain.Blockchain.get_solution_by_id"><code class="name flex">
<span>def <span class="ident">get_solution_by_id</span></span>(<span>self, id: int) ‑> Optional[<a title="ilpcoin.common.ilp.IlpSolution" href="ilp.html#ilpcoin.common.ilp.IlpSolution">IlpSolution</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Check if a solution for the ilp with id <code>id</code> exists on the chain, and return it if it does. </p>
<p>This is used by the queue to service client requests.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_solution_by_id(self, id:int) -&gt;  Optional[IlpSolution]:
    &#39;&#39;&#39;Check if a solution for the ilp with id `id` exists on the chain, and return it if it does. 
    
    This is used by the queue to service client requests.
    &#39;&#39;&#39;
    for b in self.blockchain:
        if int(b.ILP) == int(id):
            return b.ILP_solution
    return None</code></pre>
</details>
</dd>
<dt id="ilpcoin.common.blockchain.Blockchain.get_top"><code class="name flex">
<span>def <span class="ident">get_top</span></span>(<span>self) ‑> Optional[<a title="ilpcoin.common.blockchain.Block" href="#ilpcoin.common.blockchain.Block">Block</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the block at the head of the blockchain, or None of the chain is empty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_top(self) -&gt; Optional[Block]:
    &#39;&#39;&#39;Get the block at the head of the blockchain, or None of the chain is empty. &#39;&#39;&#39;
    if self.blockchain == []:
        return None
    else:
        return self.blockchain[len(self.blockchain) - 1]</code></pre>
</details>
</dd>
<dt id="ilpcoin.common.blockchain.Blockchain.get_value_by_user"><code class="name flex">
<span>def <span class="ident">get_value_by_user</span></span>(<span>self, user: str, block_index: int, trans_index: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Replay the blockchain up to block_index:trans_index to determine how much ilpcoin the user currently has.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_value_by_user(self, user: str, block_index: int, trans_index: int) -&gt; int:
    &#39;&#39;&#39;Replay the blockchain up to block_index:trans_index to determine how much ilpcoin the user currently has.&#39;&#39;&#39;
    amount = 0

    # pool up all the money owned by this sender
    for block in self.blockchain[:block_index]:

        # handle transaction fee
        if user == block.transactions[0].sender:
            amount += block.transactions[0].amount

        for t in block.transactions[1:trans_index]:
            if t.sender == user:
                amount -= t.amount
            if t.receiver == user:
                amount += t.amount
    return amount</code></pre>
</details>
</dd>
<dt id="ilpcoin.common.blockchain.Blockchain.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize this blockchain to bytes, using pickle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self) -&gt; bytes:
    &#39;&#39;&#39;Serialize this blockchain to bytes, using pickle.&#39;&#39;&#39;
    return pickle.dumps(self)</code></pre>
</details>
</dd>
<dt id="ilpcoin.common.blockchain.Blockchain.verify_blockchain"><code class="name flex">
<span>def <span class="ident">verify_blockchain</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Verify the integrity of the blockciain. </p>
<p>Replays the entire chain for consistency and valid proof of work: both nonces and Ilp solutions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_blockchain(self) -&gt; bool:
    &#39;&#39;&#39;Verify the integrity of the blockciain. 

    Replays the entire chain for consistency and valid proof of work: both nonces and Ilp solutions.
    &#39;&#39;&#39;
    previous = None
    for i in range(len(self.blockchain)):
        if not self.blockchain[i].validate_block(previous, HARDNESS):
            return False 
        previous = self.blockchain[i]
        
        # skip genesis transaction - that&#39;s a blockwide property
        for t in range(1, len(self.blockchain[i].transactions[1:])):
            if not self.verify_transaction(self.blockchain[i].transactions[t], i, t):
                return False 
    return True </code></pre>
</details>
</dd>
<dt id="ilpcoin.common.blockchain.Blockchain.verify_transaction"><code class="name flex">
<span>def <span class="ident">verify_transaction</span></span>(<span>self, transaction: <a title="ilpcoin.common.blockchain.Transaction" href="#ilpcoin.common.blockchain.Transaction">Transaction</a>, block_index: int, trans_index: int) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Verify that transaction on this chain at block_index:trans_index does not double spend.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_transaction(self, transaction: Transaction, block_index: int, trans_index: int) -&gt; bool:
    &#39;&#39;&#39;Verify that transaction on this chain at block_index:trans_index does not double spend.&#39;&#39;&#39;
    amount = self.get_value_by_user(transaction.sender, block_index, trans_index)
    return not (amount &lt; transaction.amount)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="ilpcoin.common.blockchain.Transaction"><code class="flex name class">
<span>class <span class="ident">Transaction</span></span>
<span>(</span><span>sender: str = '', receiver: str = '', amount: int = 0)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a transaction, a group of which comprise a block. </p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>sender</code></strong> :&ensp;<code>string</code></dt>
<dd>The user who sends this transaction.</dd>
<dt><strong><code>receiver</code></strong> :&ensp;<code>string</code></dt>
<dd>The receiver of the transaction.</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>int</code></dt>
<dd>The amount of ilpcoin transferred.</dd>
</dl>
<p>Initializes a transaction.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Transaction:

    &#39;&#39;&#39;Represents a transaction, a group of which comprise a block. 

    Attributes
    ----------
    sender : string
        The user who sends this transaction.
    receiver : string
        The receiver of the transaction. 
    amount : int
        The amount of ilpcoin transferred. 
    &#39;&#39;&#39;

    def __init__(self, sender:str=&#39;&#39;, receiver: str=&#39;&#39;, amount: int=0):
        &#39;&#39;&#39;Initializes a transaction.&#39;&#39;&#39;
        self.sender = sender
        self.receiver = receiver
        self.amount = amount

    def __eq__(self, other:&#39;Transaction&#39;):
        check = self.sender == other.sender
        check &amp;= self.receiver == other.receiver
        check &amp;= self.amount == other.amount
        return check
        
    def hash(self) -&gt; str:
        &#39;&#39;&#39;Generate the sha256 hash of this transaction.&#39;&#39;&#39;
        to_hash = bytes(self.sender+self.receiver+str(self.amount), &#39;utf-8&#39;)
        return hashlib.sha256(to_hash).hexdigest()
    
    def serialize(self) -&gt; bytes:
        &#39;&#39;&#39;Serialize this transaction to bytes, using pickle.&#39;&#39;&#39;
        return pickle.dumps(self)
    
    @classmethod
    def deserialize(cls, data: bytes):
        &#39;&#39;&#39;Inverse of serialize. Returns a Transaction.&#39;&#39;&#39;
        return pickle.loads(data)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="ilpcoin.common.blockchain.Transaction.deserialize"><code class="name flex">
<span>def <span class="ident">deserialize</span></span>(<span>data: bytes)</span>
</code></dt>
<dd>
<div class="desc"><p>Inverse of serialize. Returns a Transaction.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def deserialize(cls, data: bytes):
    &#39;&#39;&#39;Inverse of serialize. Returns a Transaction.&#39;&#39;&#39;
    return pickle.loads(data)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ilpcoin.common.blockchain.Transaction.hash"><code class="name flex">
<span>def <span class="ident">hash</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generate the sha256 hash of this transaction.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hash(self) -&gt; str:
    &#39;&#39;&#39;Generate the sha256 hash of this transaction.&#39;&#39;&#39;
    to_hash = bytes(self.sender+self.receiver+str(self.amount), &#39;utf-8&#39;)
    return hashlib.sha256(to_hash).hexdigest()</code></pre>
</details>
</dd>
<dt id="ilpcoin.common.blockchain.Transaction.serialize"><code class="name flex">
<span>def <span class="ident">serialize</span></span>(<span>self) ‑> bytes</span>
</code></dt>
<dd>
<div class="desc"><p>Serialize this transaction to bytes, using pickle.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serialize(self) -&gt; bytes:
    &#39;&#39;&#39;Serialize this transaction to bytes, using pickle.&#39;&#39;&#39;
    return pickle.dumps(self)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ilpcoin.common" href="index.html">ilpcoin.common</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ilpcoin.common.blockchain.BadBlockError" href="#ilpcoin.common.blockchain.BadBlockError">BadBlockError</a></code></h4>
</li>
<li>
<h4><code><a title="ilpcoin.common.blockchain.BadTransactionError" href="#ilpcoin.common.blockchain.BadTransactionError">BadTransactionError</a></code></h4>
</li>
<li>
<h4><code><a title="ilpcoin.common.blockchain.Block" href="#ilpcoin.common.blockchain.Block">Block</a></code></h4>
<ul class="">
<li><code><a title="ilpcoin.common.blockchain.Block.deserialize" href="#ilpcoin.common.blockchain.Block.deserialize">deserialize</a></code></li>
<li><code><a title="ilpcoin.common.blockchain.Block.hash" href="#ilpcoin.common.blockchain.Block.hash">hash</a></code></li>
<li><code><a title="ilpcoin.common.blockchain.Block.serialize" href="#ilpcoin.common.blockchain.Block.serialize">serialize</a></code></li>
<li><code><a title="ilpcoin.common.blockchain.Block.set_nonce" href="#ilpcoin.common.blockchain.Block.set_nonce">set_nonce</a></code></li>
<li><code><a title="ilpcoin.common.blockchain.Block.validate_block" href="#ilpcoin.common.blockchain.Block.validate_block">validate_block</a></code></li>
<li><code><a title="ilpcoin.common.blockchain.Block.validate_nonce" href="#ilpcoin.common.blockchain.Block.validate_nonce">validate_nonce</a></code></li>
<li><code><a title="ilpcoin.common.blockchain.Block.validate_top_of_queue" href="#ilpcoin.common.blockchain.Block.validate_top_of_queue">validate_top_of_queue</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ilpcoin.common.blockchain.Blockchain" href="#ilpcoin.common.blockchain.Blockchain">Blockchain</a></code></h4>
<ul class="two-column">
<li><code><a title="ilpcoin.common.blockchain.Blockchain.add_block" href="#ilpcoin.common.blockchain.Blockchain.add_block">add_block</a></code></li>
<li><code><a title="ilpcoin.common.blockchain.Blockchain.deserialize" href="#ilpcoin.common.blockchain.Blockchain.deserialize">deserialize</a></code></li>
<li><code><a title="ilpcoin.common.blockchain.Blockchain.get_len" href="#ilpcoin.common.blockchain.Blockchain.get_len">get_len</a></code></li>
<li><code><a title="ilpcoin.common.blockchain.Blockchain.get_solution_by_id" href="#ilpcoin.common.blockchain.Blockchain.get_solution_by_id">get_solution_by_id</a></code></li>
<li><code><a title="ilpcoin.common.blockchain.Blockchain.get_top" href="#ilpcoin.common.blockchain.Blockchain.get_top">get_top</a></code></li>
<li><code><a title="ilpcoin.common.blockchain.Blockchain.get_value_by_user" href="#ilpcoin.common.blockchain.Blockchain.get_value_by_user">get_value_by_user</a></code></li>
<li><code><a title="ilpcoin.common.blockchain.Blockchain.serialize" href="#ilpcoin.common.blockchain.Blockchain.serialize">serialize</a></code></li>
<li><code><a title="ilpcoin.common.blockchain.Blockchain.verify_blockchain" href="#ilpcoin.common.blockchain.Blockchain.verify_blockchain">verify_blockchain</a></code></li>
<li><code><a title="ilpcoin.common.blockchain.Blockchain.verify_transaction" href="#ilpcoin.common.blockchain.Blockchain.verify_transaction">verify_transaction</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="ilpcoin.common.blockchain.Transaction" href="#ilpcoin.common.blockchain.Transaction">Transaction</a></code></h4>
<ul class="">
<li><code><a title="ilpcoin.common.blockchain.Transaction.deserialize" href="#ilpcoin.common.blockchain.Transaction.deserialize">deserialize</a></code></li>
<li><code><a title="ilpcoin.common.blockchain.Transaction.hash" href="#ilpcoin.common.blockchain.Transaction.hash">hash</a></code></li>
<li><code><a title="ilpcoin.common.blockchain.Transaction.serialize" href="#ilpcoin.common.blockchain.Transaction.serialize">serialize</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>